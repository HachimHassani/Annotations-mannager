{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nexports.__esModule = true;\nvar lodash_sortby_1 = __importDefault(require(\"lodash.sortby\"));\nexports.splitWithOffsets = function (text, offsets) {\n  var lastEnd = 0;\n  var splits = [];\n  for (var _i = 0, _a = lodash_sortby_1[\"default\"](offsets, function (o) {\n      return o.start;\n    }); _i < _a.length; _i++) {\n    var offset = _a[_i];\n    var start = offset.start,\n      end = offset.end;\n    if (lastEnd < start) {\n      splits.push({\n        start: lastEnd,\n        end: start,\n        content: text.slice(lastEnd, start)\n      });\n    }\n    splits.push(__assign(__assign({}, offset), {\n      mark: true,\n      content: text.slice(start, end)\n    }));\n    lastEnd = end;\n  }\n  if (lastEnd < text.length) {\n    splits.push({\n      start: lastEnd,\n      end: text.length,\n      content: text.slice(lastEnd, text.length)\n    });\n  }\n  return splits;\n};\nexports.splitTokensWithOffsets = function (text, offsets) {\n  var lastEnd = 0;\n  var splits = [];\n  for (var _i = 0, _a = lodash_sortby_1[\"default\"](offsets, function (o) {\n      return o.start;\n    }); _i < _a.length; _i++) {\n    var offset = _a[_i];\n    var start = offset.start,\n      end = offset.end;\n    if (lastEnd < start) {\n      for (var i = lastEnd; i < start; i++) {\n        splits.push({\n          i: i,\n          content: text[i]\n        });\n      }\n    }\n    splits.push(__assign(__assign({}, offset), {\n      mark: true,\n      content: text.slice(start, end).join(' ')\n    }));\n    lastEnd = end;\n  }\n  for (var i = lastEnd; i < text.length; i++) {\n    splits.push({\n      i: i,\n      content: text[i]\n    });\n  }\n  return splits;\n};\nexports.selectionIsEmpty = function (selection) {\n  var position = selection.anchorNode.compareDocumentPosition(selection.focusNode);\n  return position === 0 && selection.focusOffset === selection.anchorOffset;\n};\nexports.selectionIsBackwards = function (selection) {\n  if (exports.selectionIsEmpty(selection)) return false;\n  var position = selection.anchorNode.compareDocumentPosition(selection.focusNode);\n  var backward = false;\n  if (!position && selection.anchorOffset > selection.focusOffset || position === Node.DOCUMENT_POSITION_PRECEDING) backward = true;\n  return backward;\n};","map":{"version":3,"names":["lodash_sortby_1","__importDefault","require","exports","splitWithOffsets","text","offsets","lastEnd","splits","_i","_a","o","start","length","offset","end","push","content","slice","__assign","mark","splitTokensWithOffsets","i","join","selectionIsEmpty","selection","position","anchorNode","compareDocumentPosition","focusNode","focusOffset","anchorOffset","selectionIsBackwards","backward","Node","DOCUMENT_POSITION_PRECEDING"],"sources":["C:\\Users\\msi\\Documents\\React-TS-login-using-jwt\\node_modules\\react-text-annotate\\src\\utils.ts"],"sourcesContent":["import sortBy from 'lodash.sortby'\n\nexport const splitWithOffsets = (text, offsets: {start: number; end: number}[]) => {\n  let lastEnd = 0\n  const splits = []\n\n  for (let offset of sortBy(offsets, o => o.start)) {\n    const {start, end} = offset\n    if (lastEnd < start) {\n      splits.push({\n        start: lastEnd,\n        end: start,\n        content: text.slice(lastEnd, start),\n      })\n    }\n    splits.push({\n      ...offset,\n      mark: true,\n      content: text.slice(start, end),\n    })\n    lastEnd = end\n  }\n  if (lastEnd < text.length) {\n    splits.push({\n      start: lastEnd,\n      end: text.length,\n      content: text.slice(lastEnd, text.length),\n    })\n  }\n\n  return splits\n}\n\nexport const splitTokensWithOffsets = (text, offsets: {start: number; end: number}[]) => {\n  let lastEnd = 0\n  const splits = []\n\n  for (let offset of sortBy(offsets, o => o.start)) {\n    const {start, end} = offset\n    if (lastEnd < start) {\n      for (let i = lastEnd; i < start; i++) {\n        splits.push({\n          i,\n          content: text[i],\n        })\n      }\n    }\n    splits.push({\n      ...offset,\n      mark: true,\n      content: text.slice(start, end).join(' '),\n    })\n    lastEnd = end\n  }\n\n  for (let i = lastEnd; i < text.length; i++) {\n    splits.push({\n      i,\n      content: text[i],\n    })\n  }\n\n  return splits\n}\n\nexport const selectionIsEmpty = (selection: Selection) => {\n  let position = selection.anchorNode.compareDocumentPosition(selection.focusNode)\n\n  return position === 0 && selection.focusOffset === selection.anchorOffset\n}\n\nexport const selectionIsBackwards = (selection: Selection) => {\n  if (selectionIsEmpty(selection)) return false\n\n  let position = selection.anchorNode.compareDocumentPosition(selection.focusNode)\n\n  let backward = false\n  if (\n    (!position && selection.anchorOffset > selection.focusOffset) ||\n    position === Node.DOCUMENT_POSITION_PRECEDING\n  )\n    backward = true\n\n  return backward\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}